# `exec_record_decorators.py` 文档

此文件定义了 `@execution_handler` 装饰器，它为所有被 `TaskIQ` 执行的后台任务提供了一个统一的、健壮的执行与记录框架。

## `@execution_handler` 装饰器

这是一个异步装饰器，它包裹在实际的任务逻辑函数之外，旨在自动处理任务执行过程中的通用关注点，如日志记录、性能监控和结果持久化。

### 核心功能与流程

1.  **上下文提取**: 
    - 在任务执行前，它会尝试从函数的参数（`*args`, `**kwargs`）中提取出 `config_id`（任务配置的数据库ID）和 `context`（由 `TaskIQ` 注入的上下文对象）。
    - 它会从 `context` 对象中安全地解析出由 `TaskIQ` 分配的 `task_id`，这是每次任务执行的唯一标识符。

2.  **执行与监控**: 
    - 记录任务开始执行的时间 (`start_time`)。
    - 将原始的任务函数调用包裹在一个大的 `try...except` 块中。

3.  **成功处理**: 
    - 如果任务函数成功执行完毕（没有抛出任何异常），装饰器会：
        - 计算任务的总执行时长。
        - 调用内部的 `_create_execution_record` 函数，将执行结果（成功状态、开始/结束时间、时长、返回值）存入数据库的 `TaskExecution` 表中。
        - 返回任务的原始执行结果。

4.  **异常处理**: 
    - **超时/取消 (`asyncio.CancelledError`)**: 如果任务因为超时而被 `TaskIQ` 取消，装饰器会捕获这个特定的异常，并调用 `_create_execution_record` 将执行结果记录为**失败**，错误信息明确指出是“任务被取消(超时)”。
    - **其他所有异常 (`Exception`)**: 如果任务执行过程中发生任何其他类型的错误，装饰器同样会捕获，并调用 `_create_execution_record` 将结果记录为**失败**，同时保存详细的错误信息 (`error_message`) 和完整的堆栈跟踪 (`error_traceback`)。
    - **重新抛出**: 在记录完失败信息后，装饰器会**重新抛出**原始的异常。这一点非常重要，因为它确保了 `TaskIQ` 的上层逻辑能够知道任务失败了，并据此更新任务的状态（例如，在 `TaskIQ` 的监控界面中显示为 `failure`）。

### `_create_execution_record(...)` 内部函数

- **功能**: 这是一个异步的辅助函数，负责将任务的执行记录持久化到数据库。
- **实现**: 
    - 它使用 `AsyncSessionLocal` 来获取一个独立的数据库会话。
    - 调用 `crud_task_execution.create` 方法（一个通用的CRUD操作）来创建一个新的 `TaskExecution` 记录。
    - 包含了自身的异常处理，确保即使数据库记录失败，也不会影响到主任务的执行流程。

## 总结

`@execution_handler` 装饰器极大地简化了任务函数的编写。开发者在编写具体的任务逻辑时，无需再关心如何记录日志、如何处理异常、如何将执行结果存入数据库等通用问题。他们只需要专注于实现核心的业务逻辑即可。这个装饰器通过AOP（面向切面编程）的方式，将这些横切关注点（cross-cutting concerns）与业务逻辑完全解耦，提高了代码的可维护性和复用性。
