# `cache_decorators.py` 文档

此文件定义了两个核心的Python装饰器——`@cache` 和 `@invalidate`，它们共同构成了一个基于标签的、自动化的缓存系统。

## `@cache(tags, ttl, exclude_params)` 装饰器

这是一个异步装饰器，用于自动缓存函数的执行结果。

### 功能与逻辑

1.  **缓存键生成**: 在函数执行前，它会调用内部的 `_generate_cache_key` 函数来生成一个唯一的缓存键。
2.  **缓存命中 (Cache Hit)**: 尝试使用生成的键从Redis中获取数据。如果获取成功，会使用 `CacheSerializer` 对数据进行反序列化，并直接返回结果，不再执行原函数。
3.  **缓存未命中 (Cache Miss)**: 如果在Redis中没有找到数据，它会执行被装饰的原始函数。
4.  **缓存结果**: 函数执行完毕后，如果结果不为 `None`，它会使用 `CacheSerializer` 将结果序列化，然后存入Redis。同时，它会将这个缓存键与装饰器参数中提供的所有 `tags` 进行关联。
5.  **异常安全**: 整个过程被包裹在 `try...except` 块中。如果缓存系统（如Redis连接、序列化）出现任何问题，它会记录一个错误日志，然后直接执行原始函数并返回结果，确保缓存的故障不会影响核心业务逻辑。

### 参数
- `tags: List[CacheTags]`: 一个缓存标签的列表。这是实现“批量失效”的关键。例如，所有与用户资料相关的缓存都可以被打上 `CacheTags.USER_PROFILE` 的标签。
- `ttl: int` (可选): 缓存的过期时间（秒）。如果未提供，则使用 `CacheConfig.DEFAULT_TTL`。
- `exclude_params: List[str]` (可选): 一个字符串列表，指定在生成缓存键时需要**忽略**的函数参数名。这非常重要，通常用于忽略那些非业务相关或不稳定的参数，如数据库会话 `db`、请求对象 `request` 等。

### `_generate_cache_key(...)` 内部函数
- **功能**: 负责创建唯一的、可复现的缓存键。
- **实现**: 
    1.  使用Python的 `inspect` 模块来获取函数的签名，并将传入的 `*args` 和 `**kwargs` 准确地绑定到对应的参数名上。
    2.  根据 `exclude_params` 列表，从绑定后的参数中移除不需要的项。
    3.  **特殊处理 `current_user`**: 即使 `current_user` 被排除了，它也会尝试提取用户的唯一标识（如 `user.id`），并将其加入到缓存键中。这确保了缓存是按用户隔离的，用户A不会看到用户B的缓存数据。
    4.  将函数名、模块名和经过排序、过滤后的参数组合成一个稳定的字符串。
    5.  最后，使用 `md5` 对这个字符串进行哈希，并加上标签作为前缀，生成最终的缓存键（如 `user_profile:abcdef123456...`）。

## `@invalidate(tags)` 装饰器

这是一个用于“缓存失效”的异步装饰器。

### 功能与逻辑

- 它通常被用在会**修改**数据的函数上（如更新用户资料、删除文章等）。
- 在被装饰的函数**成功执行之后**，它会根据提供的 `tags` 列表，调用 `cache_redis_service.invalidate_by_tag` 方法，删除所有与这些标签关联的缓存键。
- 例如，在一个更新用户名的函数上使用 `@invalidate(tags=[CacheTags.USER_PROFILE, CacheTags.USER_ME])`，当函数执行成功后，所有关于该用户资料和“我的信息”的缓存都会被自动清除。

## 总结

这两个装饰器提供了一个非常优雅和声明式的方式来管理缓存。开发者只需要在需要缓存的查询函数上添加 `@cache` 装饰器，在会改变数据的操作函数上添加 `@invalidate` 装饰器，就可以实现复杂的缓存逻辑，而无需在业务代码中编写任何与缓存相关的命令式代码。
